from ast import Call
from dataclasses import dataclass
from importlib.metadata import files
from importlib.resources import path
from pathlib import Path
import re
from datetime import datetime
from typing import Generic, Iterator, List, Optional, TypeVar, Callable

'''
Terminology :

Conflict file: A conflict file is a file generated by the mobile application
DriveSync when there is two 
'''

@dataclass
class FolderPath :
    path : Path

    def valid(self) -> bool:
        return self.path.is_dir()

@dataclass
class FilePath :
    path : Path

    def valid(self) -> bool:
        return self.path.is_file()

@dataclass
class ConflictData :
    original_path : Path
    conflict_path : Path
    conflict_date : datetime

    @staticmethod
    def parse_path(p : Path) -> Optional['ConflictData'] :
        stem = p.absolute().stem
        suffix = p.suffix
        stem_regex = r'/(?P<conflict_source>.*) \(conflict (?P<date>\d\d\d\d-\d\d-\d\d-\d\d-\d\d-\d\d)\)$'
        conflict_data = re.match(stem_regex, stem)
        if conflict_data :
            return ConflictData( original_path = Path(conflict_data.group('conflict_source') + suffix)
                               , conflict_path = Path(stem + suffix)
                               , conflict_date = datetime.strptime(conflict_data.group('conflict_date'), '%Y-%m-%d-%H-%M-%S')
                               )
        return None

class FolderContentIterator :
    iter_files : Iterator[FilePath]
    iter_folders : Iterator[FolderPath]
    on_files : bool

    def __init__(self, folder_content : 'FolderContent') -> None:
        self.iter_files = iter(folder_content.files)
        self.iter_folders = iter(folder_content.folders)
        self.on_files = True

    def __iter__(self) -> None:
        pass

    def __next__(self) -> Path:
        if self.on_files :
            try :
                return self.iter_files.__next__().path
            except StopIteration :
                self.on_files = False
                return self.__next__()
        else :
            return self.iter_folders.__next__().path

@dataclass
class FolderContent :
    path    : FolderPath
    files   : List[FilePath]
    folders : List[FolderPath]

def children(folder_path : FolderPath) -> List[Path] :
    return list([folder_path.path/x for x in folder_path.path.iterdir()])

def content(folder_path : FolderPath) -> FolderContent :
    content = FolderContent(folder_path, [], [])
    for child_path in children(folder_path) :
        if child_path.is_file() :
            content.files.append(FilePath(child_path))
        elif child_path.is_dir() :
            content.folders.append(FolderPath(child_path))
        else:
            pass  # TODO: Maybe add an error message
    return content

@dataclass
class RecursiveFolderContent :
    path    : FolderPath
    files   : List[FilePath]

T = TypeVar('T')
U = TypeVar('U')

# @dataclass
# class ExtendCurry(Generic[T, U]) :
#     f : Callable[[T], U]
#     x : T
# 
#     def __call__(self) -> U:
#         return self.f(self.x)

@dataclass
class LazyExtend(Generic[T, U]) :
    f : Callable[['Lazy[T]'], U]

    def __call__(self, l : 'Lazy[T]') -> 'Lazy[U]':
        return Lazy[U](lambda : self.f(l))

class LazyPolicy :
    @staticmethod
    def extract(l : 'Lazy[T]') -> T :
        return l()

    @staticmethod
    def duplicate(l : 'Lazy[T]') -> 'Lazy[Lazy[T]]' :
        return Lazy[Lazy[T]](lambda : l)
    
    @staticmethod
    def extend(f : Callable[['Lazy[T]'], U]) -> Callable[['Lazy[T]'], 'Lazy[U]'] :
        return LazyExtend[T, U](f)


@dataclass
class Lazy(Generic[T]) :
    f : Callable[[], T]

    def __call__(self) -> T:
        return self.f()     












    

